import type { BigNumberish } from 'ethers'

export type UserOperation = {
	sender: string
	nonce: BigNumberish

	factory?: string
	factoryData?: string

	paymaster?: string
	paymasterData?: string

	maxFeePerGas: BigNumberish
	maxPriorityFeePerGas: BigNumberish

	callGasLimit: BigNumberish
	verificationGasLimit: BigNumberish
	preVerificationGas: BigNumberish

	paymasterVerificationGasLimit?: BigNumberish
	paymasterPostOpGasLimit?: BigNumberish

	callData: string
	signature: string

	eip7702Auth?: EIP7702Authorization
}

export type UserOperationHex = {
	sender: string
	nonce: string

	factory?: string
	factoryData?: string

	paymaster?: string
	paymasterData?: string

	maxFeePerGas: string
	maxPriorityFeePerGas: string

	callGasLimit: string
	verificationGasLimit: string
	preVerificationGas: string

	paymasterVerificationGasLimit?: string
	paymasterPostOpGasLimit?: string

	callData: string
	signature: string

	eip7702Auth?: {
		chainId: string
		address: string
		nonce: string

		yParity: string
		r: string
		s: string
	}
}

export type PackedUserOperation = {
	sender: string // address
	nonce: bigint // uint256
	initCode: string // bytes
	callData: string // bytes
	accountGasLimits: string // bytes32
	preVerificationGas: bigint // uint256
	gasFees: string // bytes32
	paymasterAndData: string // bytes
	signature: string // bytes
}

export type EIP7702Authorization = {
	chainId: BigNumberish
	address: string
	nonce: BigNumberish

	yParity: BigNumberish
	r: BigNumberish
	s: BigNumberish
}

export type EstimateUserOperationGasResponse = {
	preVerificationGas: bigint
	verificationGasLimit: bigint
	callGasLimit: bigint
	paymasterVerificationGasLimit?: bigint
}

export type EstimateUserOperationGasResponseHex = {
	preVerificationGas: string
	verificationGasLimit: string
	callGasLimit: string
	paymasterVerificationGasLimit?: string
}

/**
 * * If the `UserOperation` is included in a block:
 *   * Return a full UserOperation, with the addition of `entryPoint`, `blockNumber`, `blockHash` and `transactionHash`.
 *
 * * Else if the `UserOperation` is pending in the bundler's mempool:
 *   *  MAY return `null`, or a full `UserOperation`, with the addition of the `entryPoint` field and a `null` value for `blockNumber`, `blockHash` and `transactionHash`.
 *
 * * Else:
 *   * Return `null`
 */
export type GetUserOperationByHashResponse =
	| (UserOperationHex & {
			entryPoint: string
			blockNumber: string | null
			blockHash: string | null
			transactionHash: string | null
	  })
	| null

/**
 * - **userOpHash** - the request hash
 * - **entryPoint** - the entry point address
 * - **sender** - the sender address
 * - **nonce** - the nonce value
 * - **paymaster** - the paymaster used for this userOp (or empty)
 * - **actualGasCost** - the actual amount paid (by account or paymaster) for this `UserOperation`
 * - **actualGasUsed** - total gas used by this `UserOperation`, including pre-verification, creation, validation and execution
 * - **success** - boolean indicating whether this execution completed without a revert
 * - **reason** - in case of reverted `UserOperation`, the returned revert reason byte array
 * - **logs** - the logs generated by this particular `UserOperation`, not including logs of other `UserOperations` in the same bundle
 * - **receipt** - the `TransactionReceipt` object. Note that the returned `TransactionReceipt` is for the entire bundle, not only for this `UserOperation`.
 */
export type UserOperationReceipt = {
	userOpHash: string
	entryPoint: string
	sender: string
	nonce: string
	paymaster: string
	actualGasUsed: bigint
	actualGasCost: bigint
	success: boolean
	logs: UserOperationLog[]
	receipt: {
		transactionHash: string
		transactionIndex: bigint
		from: string
		to: string
		status: bigint
		logsBloom?: string
		blockHash: string
		blockNumber: bigint
		contractAddress: null | string
		gasUsed: bigint
		cumulativeGasUsed: bigint
		effectiveGasPrice: bigint
		logs: UserOperationLog[]
	}
}

export type UserOperationReceiptHex = {
	userOpHash: string
	entryPoint: string
	sender: string
	nonce: string
	paymaster: string
	actualGasUsed: string
	actualGasCost: string
	success: boolean
	logs: UserOperationLogHex[]
	receipt: {
		transactionHash: string
		transactionIndex: string
		from: string
		to: string
		status: string
		logsBloom: string
		blockHash: string
		blockNumber: string
		contractAddress: null | string
		gasUsed: string
		cumulativeGasUsed: string
		effectiveGasPrice: string
		logs: UserOperationLogHex[]
	}
}

export type UserOperationLog = {
	logIndex: bigint
	transactionIndex: bigint
	transactionHash: string
	blockHash: string
	blockNumber: bigint
	address: string
	data: string
	topics: string[]
}

export type UserOperationLogHex = {
	logIndex: string
	transactionIndex: string
	transactionHash: string
	blockHash: string
	blockNumber: string
	address: string
	data: string
	topics: string[]
}
